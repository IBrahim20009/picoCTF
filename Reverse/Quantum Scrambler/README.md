# Quantum Scrambler â€” Reverse Engineering Write-Up

## ğŸ” Overview

This challenge provides a scrambled version of the flag, generated by a custom Python function. Our task is to understand how the **quantum_scrambler.py** script transforms the flag and then reverse that transformation using the output script **solve.py**.

The challenge gives us:

* The scrambling code (`quantum_scrambler.py`)
* A script that prints the real flag in an encoded layout (`solve.py`)
* The flag file (`flag.txt`), which contains the scrambled structure

We analyze how the scramble works, why the output looks the way it does, and how the solver extracts the flag.

---

## ğŸ“ Files Provided

### **1. solve.py** (decoder)

This script reads the scrambled flag from `flag.txt` and prints a readable form:

```
f = eval(open("flag.txt","r").read())
for i in f:
    print(i[0], i[-1], end="")
```

What it does:

* Loads the scrambled structure (a Python list of lists)
* For each element, prints the **first** and **last** values in that element
* These values reconstruct the original flag

### **2. quantum_scrambler.py** (encoder)

This file defines how the flag was originally scrambled. Key functions:

#### `get_flag()`

Reads the flag and converts it into a list of hex digits:

```python
hex_flag.append([str(hex(ord(c)))])
```

Each character becomes a list with a *single* element.

#### `scramble(L)`

This function mutates the list:

```python
A[i-2] += A.pop(i-1)
A[i-1].append(A[:i-2])
```

This means:

* Elements get **combined** into bigger lists
* Sub-lists get **nested** inside other lists
* The structure grows in depth and complexity

The result is a heavily nested list stored inside `flag.txt`.

---

## ğŸ§  Understanding the Scramble

The scramble does **not** truly encrypt the data â€” it only rearranges list structure.

Important observations:

* **The values (hex codes) themselves are never modified.**
* Only the *list nesting* changes.
* Every character of the flag still exists somewhere inside the nested structure.
* For each character, the **first** and **last** positions in the scrambled block correspond to the same characterâ€™s encoding.

This is why the solver works:

```python
for i in f:
    print(i[0], i[-1], end="")
```

It simply extracts the outermost elements of each sublist.

---

## ğŸ§ª Decoding Logic

Given an entry in the scrambled flag structure:

```
['0x70', '0x7d', [...nested mess...]]
```

The first value (`i[0]`) is the hex for one character.
The last value (`i[-1]`) is the hex for the next character.

When printed sequentially, the solve script reconstructs the original flag.

---

## â–¶ï¸ Running the Solver

```
python3 solve.py
```

This outputs the actual flag in clean, readable form.

---

## ğŸ‰ Final Flag

The reconstructed flag is:

```
picoCTF{...}
```

(Your real flag appears when running `solve.py`.)

---

## ğŸ§  Key Takeaways

* The scramble mutates *structure*, not *data*.
* The underlying hex values remain intact.
* Extracting the first and last elements from each sublist reveals the flag.
* This is a great example of reverse engineering through **data structure analysis** rather than decryption.

---


